(window.webpackJsonp=window.webpackJsonp||[]).push([["e6cc","29e8"],{Juyh:function(e,n,a){"use strict";a.r(n);var t=a("q1tI"),m=a.n(t),o=a("yq60");n.default=function(){return m.a.createElement(m.a.Fragment,null,m.a.createElement("p",null,"Welcome to About!"),m.a.createElement(o.default,null))}},rB5V:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/about",function(){var e=a("Juyh");return{page:e.default||e}}])},yq60:function(e,n,a){"use strict";a.r(n);var t=a("qNsG"),m=a("q1tI"),o=a.n(m),c=a("6qfE");n.default=function(e){var n=e.components;Object(t.a)(e,["components"]);return o.a.createElement(c.MDXTag,{name:"wrapper",components:n},o.a.createElement(c.MDXTag,{name:"h1",components:n},"在循环中使用 async/await"),o.a.createElement(c.MDXTag,{name:"p",components:n},o.a.createElement(c.MDXTag,{name:"em",components:n,parentName:"p"},"随着 Nodejs 7.6.0 的发布，开发者终于可以在不加 flag 的情况下使用 async/await 了！")),o.a.createElement(c.MDXTag,{name:"h2",components:n},"0x00 发现问题"),o.a.createElement(c.MDXTag,{name:"p",components:n},"尝试遍历数组，在 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"foreach")," 方法中传入一个 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"async")," 函数。"),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript",metaString:""}},"async function insert(db, categories) {\n  categories.forEach(async (category) => {\n      await db.insertOne(category);\n      console.log(`Document created: ${category}.`);\n    });\n  });\n\n  await db.close();\n  console.log('close!');\n}\n")),o.a.createElement(c.MDXTag,{name:"p",components:n},"结果自然是在遍历 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"categories")," 回调完成之前就会先关闭 db 连接，导致 insert 操作不能顺利进行。",o.a.createElement(c.MDXTag,{name:"br",components:n,parentName:"p"}),"那么问题来了，在循环操作中使用 ",o.a.createElement(c.MDXTag,{name:"em",components:n,parentName:"p"},"async/await")," 的正确姿势是什么？"),o.a.createElement(c.MDXTag,{name:"h2",components:n},"0x01 并行的异步操作"),o.a.createElement(c.MDXTag,{name:"p",components:n},"我们来完成一个异步 log 的功能来模拟各种异步任务："),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript",metaString:""}},"const sequence = [3e3, 2e3, 1e3];\n\nfunction wait(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`waited ${ms} ms!`);\n    }, ms);\n  });\n}\n\nsequence.forEach(async (ms) => {\n  const result = await wait(ms);\n  console.log(result);\n});\n")),o.a.createElement(c.MDXTag,{name:"p",components:n},"运行这段代码，输出为："),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-nohighlight",metaString:""}},"waited 1000 ms!\nwaited 2000 ms!\nwaited 3000 ms!\n")),o.a.createElement(c.MDXTag,{name:"p",components:n},"可以看到，我们通过 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Array.prototype.forEach")," 方法对 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sequence")," 中的每一个元素添加了一个 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"async")," 回调函数，并行执行并输出结果。",o.a.createElement(c.MDXTag,{name:"br",components:n,parentName:"p"}),"这个时候我们修改一下需求，要求在所有异步任务完成之后提示用户，应该如何是好呢？"),o.a.createElement(c.MDXTag,{name:"p",components:n},o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"async")," 函数返回一个 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Promise")," 对象，在 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"forEach")," 中我们并没有对其做任何状态改变的观察，而是仅依靠函数中的副作用完成了对结果的输出。",o.a.createElement(c.MDXTag,{name:"br",components:n,parentName:"p"}),"如果想要对每一个 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Promise")," 对象都进行处理，应该结合 Promise.all 并使用 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Array.prototype.map")," 来遍历数组："),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript",metaString:""}},"Promise.all(sequence.map(async (ms) => {\n  const result = await wait(ms);\n  console.log(result);\n}))\n  .then(() => { console.log('Complete!'); });\n")),o.a.createElement(c.MDXTag,{name:"p",components:n},"输出结果："),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-nohighlight",metaString:""}},"waited 1000 ms!\nwaited 2000 ms!\nwaited 3000 ms!\nComplete!\n")),o.a.createElement(c.MDXTag,{name:"h2",components:n},"0x02 串行的异步操作"),o.a.createElement(c.MDXTag,{name:"p",components:n},"我们再次更改需求，现在我们要求异步操作按照数组中元素顺序依次执行，在上一个操作完成后再执行下一步。",o.a.createElement(c.MDXTag,{name:"br",components:n,parentName:"p"}),"为了达到这样的效果，应该使用ES6中的 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"for...of")," 来进行遍历操作："),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript",metaString:""}},"async function loopInSequence() {\n  for (const ms of sequence) {\n    const result = await wait(ms);\n    console.log(result);\n  }\n}\nloopInSequence()\n  .then(() => { console.log('Complete!'); });\n")),o.a.createElement(c.MDXTag,{name:"p",components:n},"在 ",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"for...of")," 循环中，",o.a.createElement(c.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"await")," 操作能够按照预期执行，输出结果："),o.a.createElement(c.MDXTag,{name:"pre",components:n},o.a.createElement(c.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-nohighlight",metaString:""}},"waited 3000 ms!\nwaited 2000 ms!\nwaited 1000 ms!\nComplete!\n")))}}},[["rB5V","5d41","9da1"]]]);